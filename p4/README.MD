## ЗАВДАННЯ ЗАГАЛЬНЕ ДЛЯ ВСІХ
## 4.1

### Умова

Скільки пам’яті може виділити malloc(3) за один виклик? Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?

### Рішення

Теоретично, обсяг пам'яті, який можна передати в malloc(), визначається типом size_t, який на 64-бітній системі займає 8 байт (64 біти). Це дозволяє адресувати до 2⁶⁴ байт, або 16 ексабайт. Однак на практиці обмеження значно менші через кілька факторів. Сучасні 64-бітні процесори, такі як x86_64, використовують лише 48 біт для адресації пам'яті, що обмежує доступну віртуальну пам'ять до 256 терабайт. Деякі нові процесори підтримують 57 біт, що дає максимум 128 петабайт, але повна 64-бітна адресація не застосовується. Окрім того, операційні системи вводять додаткові обмеження, а фізична пам'ять часто набагато менша за теоретичні ліміти. Тому, хоча malloc() може теоретично виділити до 16 ЕБ, на практиці максимальний розмір пам'яті обмежений до 8 ЕБ або навіть менше.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p4/p4.1/image.png)

## 4.2

### Умова

Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.

### Рішення

Після переповнення змінної зі знаком значення, яке передається в malloc(), неявно інтерпретується як велике додатне число, оскільки воно перетворюється на тип size_t. Оскільки система не може виділити таку велику кількість пам'яті, malloc() повертає NULL, вказуючи на неможливість виконати операцію.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p4/p4.2/image.png)

## 4.3

### Умова

Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми

### Рішення

При виклику malloc(0) стандарт C дозволяє повернення або ненульового вказівника, або NULL. У нашому тесті malloc повернув вказівник, який можна безпечно передати в free(). Це означає, що навіть якщо кількість виділеної пам'яті дорівнює нулю, результатом може бути дійсний вказівник, і його можна коректно звільнити без помилок. Таким чином, виклик malloc(0) не є помилковим, і вказівник можна обробляти через free().

![Example Image](https://github.com/dims3926r/aspz/blob/main/p4/p4.3/image.png)

## 4.4

### Умова

Чи є помилки у такому коді? void *ptr = NULL; while () { if (!ptr) ptr = malloc(n); [... <використання 'ptr'> ...] free(ptr); }
Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.

### Рішення

Початковий код містить помилку через те, що пам'ять звільняється на кожній ітерації циклу. Це призводить до того, що на наступному кроці програма намагається звернутися до вже звільненої пам'яті, що може викликати непередбачувану поведінку або аварійне завершення. У виправленому варіанті пам'ять виділяється один раз перед циклом, а звільняється лише після завершення всіх операцій з цією пам'яттю. Такий підхід дозволяє коректно використовувати пам'ять протягом кількох ітерацій без порушень цілісності даних і помилок, пов'язаних із доступом до вже звільнених блоків.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p4/p4.4/Знімок%20екрана%202025-05-05%20214354.png)
![Example Image](https://github.com/dims3926r/aspz/blob/main/p4/p4.4/Знімок%20екрана%202025-05-05%20214401.png)

## 4.5

### Умова

Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.

### Рішення

Якщо realloc() не може виділити запитаний обсяг пам'яті, вона повертає NULL, але початковий блок пам'яті, на який вказує ptr, не звільняється. Це означає, що при помилці початкова пам'ять залишається доступною, і її потрібно звільнити вручну, щоб уникнути витоків. У тестовому випадку виклик realloc() із надто великим значенням імітує помилку, і програма коректно перевіряє результат, звільняючи початкову пам'ять, що демонструє безпечне використання realloc().

![Example Image](https://github.com/dims3926r/aspz/blob/main/p4/p4.5/image.png)

## 4.6

### Умова

Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок

### Рішення

Цей приклад демонструє особливості функції realloc(). Якщо перший аргумент — це NULL, то realloc(NULL, 100) поводиться як malloc(100), виділяючи нову пам'ять. Якщо ж викликати realloc(ptr, 0), пам'ять, на яку вказує ptr, звільняється, а сама функція повертає NULL. Таким чином, realloc() може виконувати роль як malloc, так і free, залежно від переданих аргументів.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p4/p4.6/image.png)

## 4.7

### Умова

Перепишіть наступний код, використовуючи reallocarray(3): struct sbar *ptr, newptr; ptr = calloc(1000, sizeof(struct sbar)); newptr = realloc(ptr, 500sizeof(struct sbar)); Порівняйте результати виконання з використанням ltrace.

### Рішення

У програмі використовується функція calloc для виділення пам'яті для 1000 елементів типу struct sbar і функція reallocarray для зміни розміру пам'яті на 500 елементів. Якщо виділення пам'яті не вдається, програма виводить повідомлення про помилку. Після успішного виконання виводяться адреси пам'яті до та після зміни її розміру. За допомогою ltrace можна побачити виклики функцій calloc та reallocarray, а також адреси виділеної пам'яті на кожному етапі.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p4/p4.7/image.png)

## Завдання по ВАРІАНТАХ
## 11

### Умова

Створіть сценарій, що перевіряє фрагментацію heap при виділенні/звільненні пам’яті.

### Рішення

Цей сценарій перевіряє фрагментацію heap при виділенні та звільненні пам'яті. Спочатку програма виділяє 10 блоків пам'яті по 10 МБ кожен за допомогою malloc та зберігає їхні адреси в масиві. Потім звільняються блоки з парними індексами, що створює прогалини в heap, а залишаються блоки з непарними індексами. Після цього програма намагається виділити великий блок пам'яті (50 МБ) і перевіряє, чи вдалося це зробити. Якщо виділення блоку не вдалося, ймовірно, причина полягає в фрагментації пам'яті. У кінці програма звільняє всі непарні блоки. Тестування фрагментації heap дозволяє перевірити, як динамічне виділення та звільнення пам'яті впливає на доступну область пам'яті.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p4/p11/image.png)
