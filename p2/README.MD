## 2.1

### Умова

Напишіть програму для визначення моменту, коли `time_t` закінчиться. Досліджуйте, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Досліджуйте сегменти виконуваного файлу.

### Рішення

Програма визначає розмір типу `time_t` на поточній архітектурі системи. Якщо архітектура 32-бітна, програма виводить момент, коли значення `time_t` досягне свого максимального значення, що призведе до переповнення. Для 64-бітних архітектур обмеження часу фактично не існує, тому програма повідомляє, що переповнення неможливе.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p2/p2.1/image.png)

## 2.2
### Умова
Розгляньте сегменти у виконуваному файлі.

Скомпілюйте програму "hello world", запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента
BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю. 4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні? 5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації? Проаналізуйте результати, щоб переконатися, що: ● сегмент даних зберігається у виконуваному файлі; ● сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання); ● текстовий сегмент більшою мірою піддається перевіркам оптимізації; ● на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.

### Пояснення
Досліджено, як зміни в коді (глобальні й локальні масиви, ініціалізація) впливають на сегменти .text, .data, .bss. Перевірено вплив ключів компіляції -g та -O2 на розмір файлу.

![Знімок екрана 2025-05-05 145319](https://github.com/dims3926r/aspz/blob/main/p2/p2.2/Знімок%20екрана%202025-05-05%20145319.png)

![Знімок екрана 2025-05-05 145517](https://github.com/dims3926r/aspz/blob/main/p2/p2.2/Знімок%20екрана%202025-05-05%20145517.png)

![Знімок екрана 2025-05-05 145558](https://github.com/dims3926r/aspz/blob/main/p2/p2.2/Знімок%20екрана%202025-05-05%20145558.png)

![Знімок екрана 2025-05-05 145606](https://github.com/dims3926r/aspz/blob/main/p2/p2.2/Знімок%20екрана%202025-05-05%20145606.png)

![Знімок екрана 2025-05-05 145838](https://github.com/dims3926r/aspz/blob/main/p2/p2.2/Знімок%20екрана%202025-05-05%20145838.png)

## 2.3

### Умова  
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне розташування стека у вашій системі. Знайдіть розташування сегментів даних і тексту, а також купи всередині сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і виведіть їхні адреси. Збільшіть розмір стека, викликавши функцію й оголосивши кілька великих локальних масивів. Яка зараз адреса вершини стека?

### Рішення 
Програма визначає адреси різних сегментів пам'яті:
1. **Стек** — через локальну змінну. Стек, як правило, розташований у високих адресах і зростає до менших.
2. **Сегмент даних** — через глобальну змінну.
3. **Сегмент коду** — через адресу функції.

Програма також виводить адресу локального масиву на стеку, що дозволяє побачити, як змінюється адреса з ростом стека після виклику функції.

![Скріншот програми](https://github.com/dims3926r/aspz/blob/main/p2/p3.3/image.png)

## 2.4

### Умова  
Ознайомтеся з виводом gstack і порівняйте його з GDB.

### Рішення  
gstack виводить поточний стек викликів процесу, показуючи функції та їхні аргументи. На відміну від нього, GDB є більш функціональним інструментом: окрім перегляду стека викликів, він дозволяє налагоджувати програму, виконувати її покроково, змінювати змінні та досліджувати внутрішній стан виконання.

![Скріншот програми](https://github.com/dims3926r/aspz/blob/main/p2/p2.4/Знімок%20екрана%202025-05-05%20151816.png)

![Скріншот програми](https://github.com/dims3926r/aspz/blob/main/p2/p2.4/Знімок%20екрана%202025-05-05%20153239.png)


